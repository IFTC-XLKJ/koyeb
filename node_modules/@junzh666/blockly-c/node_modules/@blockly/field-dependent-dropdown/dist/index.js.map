{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/field-dependent-dropdown/webpack/universalModuleDefinition","webpack://@blockly/field-dependent-dropdown/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/field-dependent-dropdown/webpack/bootstrap","webpack://@blockly/field-dependent-dropdown/webpack/runtime/define property getters","webpack://@blockly/field-dependent-dropdown/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/field-dependent-dropdown/webpack/runtime/make namespace object","webpack://@blockly/field-dependent-dropdown/./src/dependent_dropdown_options_change.ts","webpack://@blockly/field-dependent-dropdown/./src/field_dependent_dropdown.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview An event representing when a dependent dropdown field changes\n * state.\n */\n\nimport * as Blockly from 'blockly/core';\nimport type {FieldDependentDropdown} from './field_dependent_dropdown';\n\n/**\n * A deep equality comparison between the two provided arrays recursively\n * comparing any child elements that are also arrays.\n *\n * @param a The first array to compare.\n * @param b The second array to compare.\n * @returns Whether the arrays are deeply equivalent.\n */\nfunction arraysAreEquivalent<T>(a: T[], b: T[]): boolean {\n  return (\n    a.length === b.length &&\n    a.every((aElement, index) => {\n      const bElement = b[index];\n      if (Array.isArray(aElement) && Array.isArray(bElement)) {\n        return arraysAreEquivalent(aElement, bElement);\n      }\n      return aElement === bElement;\n    })\n  );\n}\n\n/** The structure of a serialized DependentDropdownOptionsChange. */\nexport interface DependentDropdownOptionsChangeJson\n  extends Blockly.Events.BlockBaseJson {\n  name: string;\n  newValue: string;\n  oldValue: string;\n  oldOptions: Blockly.MenuOption[];\n  newOptions: Blockly.MenuOption[];\n}\n\n/**\n * A change event representing a simultaneous change to a dropdown field's\n * options and value. The old value must be one of the old options, and the new\n * value must be one of the new options. Unlike a normal value change event,\n * it's possible for this event to change the value to something that wasn't\n * previously one of the valid options--in either direction--by also changing\n * the options at the same time.\n */\nexport class DependentDropdownOptionsChange extends Blockly.Events.BlockBase {\n  /** The name to register with Blockly for the type of event. */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static readonly EVENT_TYPE: string = 'dropdown_options_change';\n\n  /** The name of the change event type for registering with Blockly. */\n  readonly type = DependentDropdownOptionsChange.EVENT_TYPE;\n\n  /** The name of the field that changed. */\n  name?: string;\n\n  /** The original value of the field. */\n  oldValue?: string;\n\n  /** The new value of the field. */\n  newValue?: string;\n\n  /** The original available options for the dropdown field. */\n  oldOptions?: Blockly.MenuOption[];\n\n  /** The new available options for the dropdown field. */\n  newOptions?: Blockly.MenuOption[];\n\n  /**\n   * Construct a new DependentDropdownOptionsChange.\n   *\n   * @param block The changed block. Undefined for a blank event.\n   * @param name Name of the field affected.\n   * @param oldValue Previous value of field.\n   * @param newValue New value of field.\n   * @param oldOptions Previous options for the dropdown.\n   * @param newOptions New options for the dropdown.\n   */\n  constructor(\n    block?: Blockly.Block,\n    name?: string,\n    oldValue?: string,\n    newValue?: string,\n    oldOptions?: Blockly.MenuOption[],\n    newOptions?: Blockly.MenuOption[],\n  ) {\n    super(block);\n\n    if (\n      !block ||\n      !name ||\n      !oldValue ||\n      !newValue ||\n      !oldOptions ||\n      !newOptions\n    ) {\n      // Blank event to be populated by fromJson.\n      return;\n    }\n\n    this.name = name;\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    this.oldOptions = oldOptions;\n    this.newOptions = newOptions;\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): DependentDropdownOptionsChangeJson {\n    const json = super.toJson() as DependentDropdownOptionsChangeJson;\n    if (\n      !this.name ||\n      !this.oldValue ||\n      !this.newValue ||\n      !this.oldOptions ||\n      !this.newOptions\n    ) {\n      throw new Error(\n        'The changed element is undefined. Either pass all needed ' +\n          'parameters to the constructor, or call fromJson.',\n      );\n    }\n    json['name'] = this.name;\n    json['oldValue'] = this.oldValue;\n    json['newValue'] = this.newValue;\n    json['oldOptions'] = this.oldOptions;\n    json['newOptions'] = this.newOptions;\n    return json;\n  }\n\n  /**\n   * Decode the JSON event.\n   *\n   * @param json JSON representation.\n   * @param workspace\n   * @param event\n   * @returns The deserialized event.\n   */\n  static fromJson(\n    json: DependentDropdownOptionsChangeJson,\n    workspace: Blockly.Workspace,\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    event?: any,\n  ): DependentDropdownOptionsChange {\n    const newEvent = super.fromJson(\n      json,\n      workspace,\n      event,\n    ) as DependentDropdownOptionsChange;\n    newEvent.name = json['name'];\n    newEvent.oldValue = json['oldValue'];\n    newEvent.newValue = json['newValue'];\n    newEvent.oldOptions = json['oldOptions'];\n    newEvent.newOptions = json['newOptions'];\n    return newEvent;\n  }\n\n  /**\n   * Does this event leave all state as it was before?\n   *\n   * @returns False if something changed.\n   */\n  isNull(): boolean {\n    const valuesAreEqual = this.oldValue === this.newValue;\n    const optionsAreEquivalent =\n      this.oldOptions === this.newOptions ||\n      (Array.isArray(this.oldOptions) &&\n        Array.isArray(this.newOptions) &&\n        arraysAreEquivalent(this.oldOptions, this.newOptions));\n    return valuesAreEqual && optionsAreEquivalent;\n  }\n\n  /**\n   * Run a change event.\n   *\n   * @param forward True if run forward, false if run backward (undo).\n   */\n  run(forward: boolean): void {\n    if (\n      !this.blockId ||\n      !this.name ||\n      !this.oldValue ||\n      !this.newValue ||\n      !this.oldOptions ||\n      !this.newOptions\n    ) {\n      console.warn(\"Can't run uninitialized event.\");\n      return;\n    }\n    const workspace = this.getEventWorkspace_();\n    const block = workspace.getBlockById(this.blockId);\n    if (!block) {\n      console.warn(\"Can't change non-existent block: \" + this.blockId);\n      return;\n    }\n\n    const dropdown = block.getField(this.name) as FieldDependentDropdown;\n    if (!dropdown) {\n      console.warn(\"Can't change non-existent dropdown field: \" + this.name);\n      return;\n    }\n\n    const value = forward ? this.newValue : this.oldValue;\n    const options = forward ? this.newOptions : this.oldOptions;\n\n    // Record the options on the dropdown for the option generator to access.\n    dropdown.dependencyData.derivedOptions = options;\n\n    // Re-run the option generator to update the options on the dropdown.\n    dropdown.getOptions(false);\n\n    // Set the value to one of the now-available options.\n    dropdown.setValue(value);\n  }\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  DependentDropdownOptionsChange.EVENT_TYPE,\n  DependentDropdownOptionsChange,\n);\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A Blockly dropdown menu field where the options can change\n * depending on the value of another field.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {DependentDropdownOptionsChange} from './dependent_dropdown_options_change';\n\n/** The type of the mapping from parent value to child options. */\nexport interface ChildOptionMapping {\n  [key: string]: Blockly.MenuOption[];\n}\n\n// This type isn't exported from Blockly so we have to derive it from the API.\ntype FieldConfig = Exclude<\n  ConstructorParameters<typeof Blockly.Field>[2],\n  undefined\n>;\n\n/** fromJson config for a dependent dropdown field. */\nexport interface FieldDependentDropdownFromJsonConfig extends FieldConfig {\n  parentName: string;\n  optionMapping: ChildOptionMapping;\n  defaultOptions?: Blockly.MenuOption[];\n}\n\n/**\n * A structure for managing data needed by the menu generator of a\n * FieldDependentDropdown.\n */\ninterface DependencyData {\n  /**\n   * A reference to the parent field of an associated dependent dropdown. Absent\n   * until the parent field is initialized. This field's value determines the\n   * available options of the child field.\n   */\n  parentField?: Blockly.Field<string>;\n\n  /**\n   * The child field's currently available menu options based on the current\n   * value of the parent field. Absent until the parent field is initialized.\n   */\n  derivedOptions?: Blockly.MenuOption[];\n}\n\n/**\n * A dropdown field that automatically updates its own options based on a\n * mapping from a parent field's value. The parent field must be attached to the\n * block before this child field.\n *\n * When this field is attached to a block, it will find the parent field and\n * attach a validator to the parent field that intercepts changes to its value\n * to update the options on this field. If the new validator is later removed\\\n * or replaced, then this dependent field will no longer function.\n */\nexport class FieldDependentDropdown extends Blockly.FieldDropdown {\n  /**\n   * Contains data used by this dropdown field's menu generator.\n   *\n   * The menu generator cannot refer directly to this FieldDependentDropdown\n   * instance, because it must be created before calling the super constructor\n   * when the \"this\" reference is not yet valid. This helper structure is used\n   * instead.\n   *\n   * This is public so that the DependentDropdownOptionsChangeJson event can\n   * update it while undoing/redoing.\n   */\n  dependencyData: DependencyData;\n\n  /** The name of the field that determines this field's options. */\n  private parentName: string;\n\n  /**\n   * The mapping from the parent field's value to this field's intended\n   * available options. The keys are strings representing the parent's possible\n   * values, and the values are the corresponding options to use in this child\n   * field.\n   */\n  private optionMapping: ChildOptionMapping;\n\n  /**\n   * An optional fallback set of options to use if the parent field's value does\n   * not match any of the keys in optionMapping.\n   */\n  private defaultOptions?: Blockly.MenuOption[];\n\n  /**\n   * Constructs a new FieldDependentDropdown.\n   *\n   * @param parentName The name of the parent field whose value determines this\n   *    field's available options.\n   * @param optionMapping A mapping from the possible values of the parent field\n   *    to the corresponding available options of this child field. The keys are\n   *    the possible values of the parent field, and the values are the\n   *    corresponding arrays of options for this child field.\n   * @param defaultOptions An optional fallback set of options to use if the\n   *    parent field's value does not match any of the keys in optionMapping.\n   * @param validator An optional function that is called to validate changes to\n   *    this field's value.\n   * @param config An optional map of general options used to configure the\n   *    field, such as a tooltip.\n   */\n  constructor(\n    parentName: string,\n    optionMapping: ChildOptionMapping,\n    defaultOptions?: Blockly.MenuOption[],\n    validator?: Blockly.FieldValidator,\n    config?: FieldConfig,\n  ) {\n    // A menu generator needs to be passed to the super constructor, but it\n    // needs to be able to reference data that hasn't been populated yet. We're\n    // not allowed to refer to \"this\" in this constructor before calling\n    // \"super\", so let's make separate structure to hold data relevant to the\n    // menu generator and populate that later.\n    const dependencyData: DependencyData = {};\n\n    // A menu option generator function for this child field that reads the\n    // derived options in the dependency data if available.\n    const menuGenerator: Blockly.MenuGeneratorFunction = () => {\n      // If derivedOptions has been initialized, use that.\n      if (dependencyData.derivedOptions) {\n        return dependencyData.derivedOptions;\n      }\n\n      // Fall back on the options corresponding to the parent field's current\n      // value (which is fine when initializing but may be out of date when\n      // making changes since the parent field's validator function triggers\n      // this function before the parent field's value is updated).\n\n      // If the parent field exists, and its value is a key in the provided\n      // option mapping, use the corresponding options.\n      if (dependencyData.parentField) {\n        const value = dependencyData.parentField.getValue();\n        if (value) {\n          const options = optionMapping[value];\n          if (options) {\n            return options;\n          }\n        }\n      }\n\n      if (defaultOptions) {\n        return defaultOptions;\n      }\n\n      // Fall back on basic default options.\n      return [['', '']];\n    };\n\n    super(menuGenerator, validator, config);\n    this.parentName = parentName;\n    this.optionMapping = optionMapping;\n    this.defaultOptions = defaultOptions;\n    this.dependencyData = dependencyData;\n  }\n\n  /**\n   * Constructs a FieldDependentDropdown from a JSON arg object.\n   *\n   * @param options A JSON object providing \"parentName\" and \"optionMapping\".\n   * @returns The new field instance.\n   */\n  static fromJson(\n    options: FieldDependentDropdownFromJsonConfig,\n  ): FieldDependentDropdown {\n    return new FieldDependentDropdown(\n      options['parentName'],\n      options['optionMapping'],\n      options['defaultOptions'],\n      undefined,\n      options,\n    );\n  }\n\n  /**\n   * Attach this field to a block.\n   *\n   * @param block The block containing this field.\n   */\n  setSourceBlock(block: Blockly.Block) {\n    super.setSourceBlock(block);\n\n    const parentField: Blockly.Field<string> | null = block.getField(\n      this.parentName,\n    );\n\n    if (!parentField) {\n      throw new Error(\n        'Could not find a parent field with the name ' +\n          this.parentName +\n          ' for the dependent dropdown.',\n      );\n    }\n\n    this.dependencyData.parentField = parentField;\n\n    const oldValidator = parentField.getValidator();\n\n    // A validator function for the parent field that has the side effect of\n    // updating the options of this child dropdown field based on the new value\n    // of the parent field whenever it changes. The validator function is a good\n    // place to do this because it is called immediately while deserializing\n    // workspaces before the following fields are deserialized, so when the\n    // child value is deserialized the appropriate options will already be\n    // available. If the parent already had a validator function, it will be\n    // composed with this one and the new value returned from it will be the\n    // basis for determining the new available options.\n    parentField.setValidator((newValue) => {\n      if (oldValidator) {\n        const validatedValue = oldValidator(newValue);\n        // If a validator returns null, that means the new value is invalid and\n        // the change should be canceled.\n        if (validatedValue === null) {\n          return null;\n        }\n        // If a validator returns undefined, that means no change. Otherwise,\n        // use the returned value as the new value.\n        if (validatedValue !== undefined) {\n          newValue = validatedValue;\n        }\n      }\n      this.updateOptionsBasedOnNewValue(newValue);\n      return newValue;\n    });\n    this.updateOptionsBasedOnNewValue(parentField.getValue() ?? undefined);\n  }\n\n  /**\n   * Updates the options of this child dropdown field based on the new value of\n   * the parent field.\n   *\n   * @param newValue The newly assigned value.\n   */\n  private updateOptionsBasedOnNewValue(newValue: string | undefined): void {\n    if (newValue == undefined) {\n      return;\n    }\n\n    const block = this.getSourceBlock();\n    if (!block) {\n      throw new Error(\n        'Could not validate a field that is not attached to a block: ' +\n          this.name,\n      );\n    }\n\n    const oldChildValue = this.getValue();\n    const oldChildOptions = this.getOptions(false);\n    let newChildOptions = this.optionMapping[newValue];\n    if (!newChildOptions) {\n      if (this.defaultOptions) {\n        newChildOptions = this.defaultOptions;\n      } else {\n        console.warn(\n          'Could not find child options for the parent value: ' + newValue,\n        );\n        return;\n      }\n    }\n\n    // If the child field's value is still available in the new options, keep\n    // it, otherwise change the field's value to the first available option.\n    const newOptionsIncludeOldValue =\n      newChildOptions.find((option) => option[1] == oldChildValue) != undefined;\n    const newChildValue = newOptionsIncludeOldValue\n      ? oldChildValue\n      : newChildOptions[0][1];\n\n    // Record the options so that the option generator can access them.\n    this.dependencyData.derivedOptions = newChildOptions;\n\n    // Re-run the option generator to update the options on the dropdown.\n    this.getOptions(false);\n\n    // Update this child field's value without broadcasting the normal change\n    // event. The normal value change event can't be properly undone, because\n    // the old value may not be one of the currently valid options, so a custom\n    // change event will be broadcast instead that handles swapping the options\n    // and the value at the same time.\n    Blockly.Events.disable();\n    this.setValue(newChildValue);\n    Blockly.Events.enable();\n\n    if (Blockly.Events.getRecordUndo()) {\n      if (!Blockly.Events.getGroup()) {\n        // Start a change group before the change event. The change event for\n        // the parent field value will be created after this function returns\n        // and will be part of the same group.\n        Blockly.Events.setGroup(true);\n        // Clear the change group later, after all related events have been\n        // broadcast, but before the user performs any more actions.\n        setTimeout(() => Blockly.Events.setGroup(false));\n      }\n\n      // Record that the child field's options and value have changed.\n      Blockly.Events.fire(\n        new DependentDropdownOptionsChange(\n          block,\n          this.name,\n          oldChildValue ?? undefined,\n          newChildValue ?? undefined,\n          oldChildOptions,\n          newChildOptions,\n        ),\n      );\n    }\n  }\n}\n\nBlockly.fieldRegistry.register(\n  'field_dependent_dropdown',\n  FieldDependentDropdown,\n);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","arraysAreEquivalent","b","length","every","aElement","index","bElement","Array","isArray","DependentDropdownOptionsChange","constructor","block","name","oldValue","newValue","oldOptions","newOptions","super","type","EVENT_TYPE","toJson","json","Error","static","workspace","event","newEvent","fromJson","isNull","valuesAreEqual","optionsAreEquivalent","run","forward","blockId","console","warn","getEventWorkspace_","getBlockById","dropdown","getField","options","dependencyData","derivedOptions","getOptions","setValue","FieldDependentDropdown","parentName","optionMapping","defaultOptions","validator","config","parentField","getValue","setSourceBlock","oldValidator","getValidator","setValidator","validatedValue","updateOptionsBasedOnNewValue","getSourceBlock","oldChildValue","oldChildOptions","newChildOptions","newChildValue","find","option","setTimeout"],"sourceRoot":""}